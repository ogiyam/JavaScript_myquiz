
function buildQuiz(){
 　const output = [];

 myQuestions.forEach(
   (currentQuestion, questionNumber) => {
     const answers = [];
     for(letter in currentQuestion.answers){
       answers.push(
         `<label>
           <input type="radio" name="question${questionNumber}" value="${letter}">
           ${letter} :
           ${currentQuestion.answers[letter]}
         </label>`
       );
     }

     output.push(
       `<div class="question"> ${currentQuestion.question} </div>
       <div class="answers"> ${answers.join('')} </div>`
     );
   }
 );
 quizContainer.innerHTML = output.join('');
}


function showResults(){
 const answerContainers = quizContainer.querySelectorAll('.answers');
 let numCorrect = 0;

 myQuestions.forEach( (currentQuestion, questionNumber) => {
   const answerContainer = answerContainers[questionNumber];
   const selector = `input[name=question${questionNumber}]:checked`;
   const userAnswer = (answerContainer.querySelector(selector) || {}).value;

   if(userAnswer === currentQuestion.correctAnswer){
     numCorrect++;
     answerContainers[questionNumber].style.color = 'green';
   }
   else{
     answerContainers[questionNumber].style.color = 'red';
   }
 });
 resultsContainer.innerHTML = `${numCorrect} 問正解 ${myQuestions.length}問不正解`;
}


const quizContainer = document.getElementById('quiz');
const resultsContainer = document.getElementById('results');
const submitButton = document.getElementById('submit');
const myQuestions = [
 {
   question: "ウォーターフォールモデルの説明は?(14)",
   answers: {
     a: "各工程を完了させてから次の工程に進む<br>",
     b: "利用者が早い段階でシステム内容を確認することができる<br>",
     c: "システムを複数のサブシステムに分割する"
   },
   correctAnswer: "a"
 },
 {
   question: "プロトタイピングモデルの説明は?(14)",
   answers: {
     a: "システム開発の中で「設計」→「プログラミング」→「テスト」を繰り返す<br>",
     b: "開発初期段階で利用者の要求をしっかりと確認してから実際の開発に移る<br>",
     c: "管理がしやすいため、大規模なシステム開発案件に向いている"
   },
   correctAnswer: "b"
 },
 {
   question: "スパイラルモデルの説明は?(14)",
   answers: {
     a: "利用者がシステム内容を確認できるのは最終段階に入ってから<br>",
     b: "開発初期段階で利用者の要求をしっかりと確認してから実際の開発に移る<br>",
     c: "システム開発の中で「設計」→「プログラミング」→「テスト」を繰り返す",
   },
   correctAnswer: "c"
 },
 {
    question: "RAD(Rapid Application Development)の説明は?(14)",
    answers: {
      a: "ソフトウェア開発で上流から下流まで順番に実施する<br>",
      b: "短期間で開発を行うことを再重要視した開発手法<br>",
      c: "試作品のソフトウェアを作成して、利用者の評価をフィードバックして開発する"
    },
    correctAnswer: "b"
 },
 {
    question: "アジャイルとXP(eXtreme Programming)の説明として間違っているのは?(14)",
    answers: {
      a: "少人数の開発に適応しやすいとされており、既存の開発手法を比較して変更を許容する柔軟性を持っている<br>",
      b: "スパイラルモデルの派生派で、より短い反復単位で迅速に開発を行う手法<br>",
      c: "既存の開発手法に基づいた、仕様を固めて開発を行う方法"
    },
    correctAnswer: "c"
 },
 {
    question: "XP(eXtreme Programming)では5つの価値と19のプラクティス（実践）が定義されているが、そのうち開発のプラクティスとして定められているのは?(14)",
    answers: {
      a: "自動テスト、シェアプログラミング、リファクタリング、ソースコードの修正、目的別インテグレーション、YAGNI<br>",
      b: "事前テスト開発、共有プログラミング、リファクタリング、ソースコードの共同開発、強化インテグレーション、YAGNI<br>",
      c: "テスト駆動開発、ペアプログラミング、リファクタリング、ソースコードの共同所有、継続的インテグレーション、YAGNI"
    },
    correctAnswer: "c"
 },
 {
    question: "アジャイル手法のソフトウェア開発において、最も重視されているリファクタリングは?(14)",
    answers: {
      a: "動作するソフトウェアを迅速に開発するために、先にテストケースを設定してからコーディングする<br>",
      b: "ソフトウェアの保守性を高めるために外部仕様を変更せずに、プログラムに内部構造を変更する<br>",
      c: "利用者のフィードバックを得るために試作品を早期に作成する"
    },
    correctAnswer: "b"
 },
 {
    question: "リバースエンジニアリングの説明として正しくないものは?(14)",
    answers: {
      a: "試作品のソフトウェアを作成して、利用者の評価をフィードバックして開発する<br>",
      b: "これによって得られた仕様で新しい開発をする手法をフォワードエンジニアリングという<br>",
      c: "既存のソフトウェアの動作を解析することでプログラムの仕様やソースコードを導き出す"
    },
    correctAnswer: "a"
 },
 {
    question: "マッシュアップの説明として正しいものは?(14)",
    answers: {
      a: "試作品のソフトウェアを作成して、利用者の評価をフィードバックして開発する<br>",
      b: "ソフトウェアの保守性を高めるために外部仕様を変更せずに、プログラムに内部構造を変更する<br>",
      c: "公開されている複数のサービスを組み合わせることで新しいサービスを作り出す手法"
    },
    correctAnswer: "c"
 },
 {
    question: "DFDの説明として正しいものは?(14)",
    answers: {
      a: "データの流れを図として表したもの<br>",
      b: "スパイラルモデルの派生派で、より短い反復単位で迅速に開発を行う手法<br>",
      c: "実体と実体間の関連という概念を使ってデータの構造を図に表したもの"
    },
    correctAnswer: "a"
 },
 {
    question: "E-R図の説明として正しいものは?(14)",
    answers: {
      a: "データの流れを視覚的にわかりやすく表現する図<br>",
      b: "オブジェクト指向モデルを表現する図<br>",
      c: "実体と実体間の関連という概念を使ってデータの構造を表した図"
    },
    correctAnswer: "c"
 },
 {
    question: "キーボード操作に慣れている利用者に対するインターフェースは?(14)",
    answers: {
      a: "項目をできるだけマウスで選択してもらい入力する<br>",
      b: "入力原票の形にとらわれず必須項目などは１ヵ所にまとめて配置し入力漏れがないようにする<br>",
      c: "使用頻度の高い操作はダブルクリックで選択できるようにする"
    },
    correctAnswer: "b"
 },
 {
    question: "コード設計を行う際のポイントについて正しいものは?(14)",
    answers: {
      a: "運用を開始した後はルール変更が難しいため、扱うデータ量を予測する必要がある<br>",
      b: "コードの桁数を運用途中で増やすことは難しいため、予測よりも多めに桁数を見積るのが得策である<br>",
      c: "コードの割り当て規則のみ、運用後も変更が可能である"
    },
    correctAnswer: "a"
 },
 {
    question: "チェックディジットについて正しいものは?(14)",
    answers: {
      a: "チェックディジットに使用される数字は読み取り時に複雑なルールにより生成される<br>",
      b: "バーコード読み取り時だけでなく、人の手で行う入力作業でも役立つ<br>",
      c: "コード設計時に決められた数字をコード末尾から２番目に付加する"
    },
    correctAnswer: "b"
 },
 {
    question: "入力ミスチェックの方法について正しく説明されているのは?(14)",
    answers: {
      a: "ニューメリックチェック：一定の順序で並んでいるか<br>シーケンスチェック：数字データに文字データ等が混入していないか<br>",
      b: "ニューターメリックチェック：桁数が正常か<br>シーラカンスチェック：バージョンが古くないか<br>",
      c: "ニューメリックチェック：数字データに文字データ等が混入していないか<br>シーケンスチェック：一定の順序で並んでいるか"
    },
    correctAnswer: "c"
 },
 {
   question: "モジュールの分割について間違っている説明は?(14)",
   answers: {
     a: "モジュール分割技法には「データの流れに着目」と「データの構造に着目」に分かれる<br>",
     b: "「データの構造に着目」にはトランザクション分割法が含まれる<br>",
     c: "各プログラムをモジュールという単位に分割・階層化することをプログラムの構造化設計という"
   },
   correctAnswer: "b"
 },
 {
   question: "モジュール強度の順序について正しいものは?（左から強→弱）(14)",
   answers: {
     a: "機能的強度→手順的強度→連絡的強度→情報的強度→時間的強度→論理的強度→暗号的強度<br>",
     b: "機能的強度→情報的強度→連絡的強度→手順的強度→時間的強度→論理的強度→暗号的強度<br>",
     c: "機能的強度→情報的強度→論理的強度→手順的強度→時間的強度→連絡的強度→暗号的強度"
   },
   correctAnswer: "b"
 },
 {
   question: "モジュール結合度の強弱から、モジュールの独立度が高く好ましいされる順序について正しいものは?（左から高→底）(14)",
   answers: {
     a: "データ結合→スタンプ結合→制御結合→共通結合→外部結合→内容結合<br>",
     b: "データ結合→内容結合→制御結合→外部結合→共通結合→スタンプ結合<br>",
     c: "データ結合→スタンプ結合→制御結合→外部結合→共通結合→内容結合",
   },
   correctAnswer: "c"
 },
 {
    question: "ブラックボックステストについて間違っている記述は?(14)",
    answers: {
      a: "同値分割では、データ範囲を種類ごとのグループに分けてそれぞれの代表的な値を使ってテストをする<br>",
      b: "限界値(境界値)分析では、それぞれのグループ値の境界前後の値をテストデータとして使用する<br>",
      c: "ブラックボックステストはモジュールの内部構造が正しく作られているかを検証する"
    },
    correctAnswer: "c"
 },
 {
    question: "ホワイトボックステストの網羅基準について正しい説明は?(14)",
    answers: {
      a: "命令網羅：Yes,Noの分岐それぞれのパターンが必要<br>",
      b: "判定条件網羅(分岐網羅)：Yesの分岐１テストパターンを通す<br>",
      c: "条件網羅：個々の条件がYes,Noの値を最低１回は満たすようにする<br>",
      d: "複数条件網羅：定義した条件の組み合わせを網羅するテスト"
    },
    correctAnswer: "c"
 },
 {
    question: "結合テストの手法であるボトムアップテストの特徴として正しいものは?(14)",
    answers: {
      a: "テスト済み上位モジュールが必要<br>",
      b: "開発初期の段階では並行作業が困難<br>",
      c: "スタブが必要<br>",
      d: "ドライバが必要"
    },
    correctAnswer: "d"
 },
 {
    question: "インタプリタとコンパイラについて間違っている記述は?(16)",
    answers: {
      a: "これら２種のように翻訳作業を行うプログラムを総称して言語プロセッサと呼ぶ<br>",
      b: "インタプリタ方式は原始プログラムを解釈しながら実行していくため、動作を確認しながら作ることができない<br>",
      c: "コンパイラ方式にはC言語やJavaなどが当てはまる"
    },
    correctAnswer: "b"
　},
 {
    question: "コンパイラの中で行われる処理について間違っているものは?(16)",
    answers: {
      a: "ソースコードに書かれているコードをトークン単位に分解する<br>",
      b: "オブジェクトコードを生成する代わりにインタプリタ用の中間コードを生成する<br>",
      c: "目的プログラム（オブジェクトプログラム）を生成する"
    },
    correctAnswer: "b"
 },
 {
    question: "リンカとローダについて間違っているものは?(16)",
    answers: {
      a: "リンカとは必要なモジュールなどを繋ぎ合わせて実行可能ファイル（ロードモジュール）をにするプログラムのことである<br>",
      b: "ローダとはロードモジュールを主記憶装置に読み込ませるプログラムのことである<br>",
      c: "リンカの作業時に使用される静的リンキングは、プログラムの実行時に共有ライブラリやシステムライブラリをロードしてリンクする手法である"
    },
    correctAnswer: "c"
 },
 {
    question: "構造化プログラミングで用いる制御構造とされる３つは?(16)",
    answers: {
      a: "再帰、繰返し、順次<br>",
      b: "繰返し、分岐、選択<br>",
      c: "選択、順次、繰返し"
    },
    correctAnswer: "c"
 },
 {
    question: "データ構造「配列」について間違っているものは?(16)",
    answers: {
      a: "配列はデータの挿入や削除は不得意であるためデータの個数が頻繁に変わる用途には適さない<br>",
      b: "配列内の個々のデータに直接アクセスすることはできない<br>",
      c: "配列は添字を増やしていく（配列の配列を作る）多次元配列とすることができる"
    },
    correctAnswer: "b"
 },
 {
    question: "データ構造「リスト」について間違っているものは?(16)",
    answers: {
      a: "リストで扱うデータにはポインタという番号がつき、個々のデータに直接アクセスができる<br>",
      b: "ポインタを書きかえればデータの挿入・削除を簡単に行うことができる<br>",
      c: "データの持ち方によって、単方向リスト・双方向リスト・循環リストの３種類がある"
    },
    correctAnswer: "a"
 },
 {
    question: "データ構造「キュー・スタック」について間違っているものは?(16)",
    answers: {
      a: "キューが利用されている例として、GUIプログラムやプリンタの印刷用キューが挙げられる<br>",
      b: "スタックは最後に格納したデータから順に処理を行う後入れ先だし方式のデータ構造である<br>",
      c: "スタックを用いた場合、A→B→C→Dの順で到着するデータの出力順は 必ずD→C→B→Aである"
    },
    correctAnswer: "c"
 },
 {
    question: "木構造について間違っているのは?(16)",
    answers: {
      a: "ファイルシステムやドメイン名などに用いられている<br>",
      b: "葉以外の節が全て２つの子を持ち、根から葉までの断層の深さが全て異なることを完全２分木という<br>",
      c: "親に対する左部分木と右部分木の関係が「左の子<親<右の子」となる２分探索木はデータの探索が容易にできる"
    },
    correctAnswer: "b"
 },
 {
    question: "データを探索するアルゴリズムに関して間違っている記述は?(16)",
    answers: {
      a: "線形探索法は先頭から順に探索する方法であり、番兵を付加すると効率的に処理が行うことができる<br>",
      b: "対象データ群が規則性を持たない場合、2分探索法を用いることで効率よく探索できる<br>",
      c: "ハッシュ法は一定の計算式（ハッシュ関数）を用いてデータの格納位置を算出する方法である"
    },
    correctAnswer: "b"
 },
 {
    question: "各アルゴリズムの平均探索回数について組み合わせが正しいものは?(16)",
    answers: {
      a: "線形探索法：(1+n)÷2<br>",
      b: "2分探索法：1回(シノニム発生確率を無視できる値の場合)<br>",
      c: "ハッシュ法:log₂n"
    },
    correctAnswer: "a"
 },
 {
    question: "データを整列させるアルゴリズムについて説明が正しいものは?(16)",
    answers: {
      a: "基本交換法（バブルソート）:隣接するデータの大小を比較・入れ替えにより全体を配列する<br>",
      b: "基本挿入法（挿入ソート）:①対象データから最小値か最大値のデータを取り出す　②先頭のデータと交換　③繰り返してで全体を整列する<br>",
      c: "基本選択法（選択ソート）:①対象のデータ列を整列済と未整列に分ける ②未整列側から整列済の適切な位置にデータを挿入して全体を整列する"
    },
    correctAnswer: "a"
 },
 {
    question: "より高速な整列アルゴリズムについて正しい説明は?(16)",
    answers: {
      a: "シェルソート：中間的な基準値を決めて値のグループ間で大小を判別し、それをもとに整列する<br>",
      b: "クイックソート：一定間隔おきに取り出した要素で部分列を作り、その中で整列し元に戻す<br>",
      c: "ヒープソート：未整列部分を順序木構造に構成、最大値もしくは最小値を取り出して整列済に戻す",
    },
    correctAnswer: "c"
 },
 {
    question: "オブジェクト指向の説明として間違っているものは?(16)",
    answers: {
      a: "データ（属性）とメソッド（手続き）を一つにまとめた概念である<br>",
      b: "特徴として情報隠蔽が利点として挙げられる「カプセル化」がある<br>",
      c: "「カプセル化」はデータがオブジェクトの管理下となるため他オブジェクトが容易にデータにアクセスすることができる"
    },
    correctAnswer: "c"
 },
 {
    question: "クラスとインスタンスについて間違っているのは?(16)",
    answers: {
      a: "クラスの考え方の基本は「オブジェクトを具体化して定義する」ことである<br>",
      b: "クラス定義に対して具体的な属性値を与えメモリ上の領域を確保して実体化したものがインスタンスである<br>",
      c: "ひとつのクラスから属性値によって様々なインスタンスが生成される"
    },
    correctAnswer: "a"
 },
 {
    question: "「クラスの階層化」について間違っているのは?(16)",
    answers: {
      a: "上位クラスをスーパークラス（基底クラス）、下位クラスをサブクラス（派生クラス）という<br>",
      b: "複数のオブジェクトに共通するインスタンスを抽出して階層化したものをクラスの階層化という<br>",
      c: "サブクラスがスーパークラスの特性を受け継ぐことを継承（インヘリタンス）という"
    },
    correctAnswer: "b"
 },
 {
    question: "クラスの関係性について間違っている説明は?(16)",
    answers: {
      a: "汎化と特化（is a関係）：上位クラスがスーパークラスと下位クラスがサブクラスの関係になるとき成り立つ<br>",
      b: "集約と分解（part of関係）：継承関係のある上位クラスと下位クラスの関係<br>",
      c: "多態性/多相性（ポリモーフィズム）：同メッセージを複数のオブジェクトに送った際それぞれが固有の処理を行う"
    },
    correctAnswer: "b"
 },
 {
    question: "オブジェクト指向分析を用いてモデリングした時、クラスとオブジェクトの関係になるのは?(16)",
    answers: {
      a: "ドラえもん、のび太<br>",
      b: "ドラえもん、ネジ<br>",
      c: "ドラえもん、人型ロボット"
    },
    correctAnswer: "c"
 },
 {
    question: "属性・メソッド・インスタンス、クラスについて間違っているものは?(16)",
    answers: {
      a: "属性：クラスの中に定義されるオブジェクトの状況を保持するための入れ物<br>",
      b: "メソッド：クラスの中に定義されるオブジェクトの持つ振る舞いを記述したもの<br>",
      c: "インスタンス：ソースプログラムがコンパイルされて実行可能なプログラムになり、それが主記憶装置にロードされ、動作可能な状態になったもの<br>",
      d: "クラス：一つのインスタンスの仕様を定義したもの"
    },
    correctAnswer: "d"
 },
 {
    question: "UML（Unified Modeling Language）についての説明として正しいのは?(16)",
    answers: {
      a: "主にオブジェクト指向プログラミングにおいて設計で用いられる統一モデリング言語である<br>",
      b: "規定されている図が１１種類あり必要に応じて使い分ける<br>",
      c: "規定ダイアグラムは大きく分けて「構造図」「振る舞い図」に二分され、振る舞い図の中のシーケンス図・コミュニケーション図をまとめて相互作用図という場合がある"
    },
    correctAnswer: "b"
 },
 {
    question: "UMLをビジネスモデリングに用いる場合、ビジネスプロセスの実行順序や条件による分岐などのワークフローを表すことができる図は?(16)",
    answers: {
      a: "オブジェクト図<br>",
      b: "アクティビティ図<br>",
      c: "コンポーネント図"
    },
    correctAnswer: "b"
 },
 {
    question: "UML2.0のシーケンス図とコミュニケーション図のどちらにも表現されるものは?(16)",
    answers: {
      a: "オブジェクトがメッセージを処理している期間<br>",
      b: "オブジェクトがある状態にとどまる最短時間あよび最長時間<br>",
      c: "オブジェクト間で送受信されるメッセージ"
    },
    correctAnswer: "c"
 },
 {
    question: "DBMSと関係データベースについて間違っている説明は?(11)",
    answers: {
      a: "DBMSとはデータベース管理システム（Data Base Management System）のことである<br>",
      b: "データベースの種類において主流とされているのが表で管理する関係型である<br>",
      c: "DBMSはデータベース機能をアプリケーションから簡単に行うことができる基本ソフトウェアである<br>",
      d: "関係データベースはRDB（Relational Database）とも呼ばれる"
    },
    correctAnswer: "c"
 },
 {
    question: "関係データベース操作のうち「射影」についての説明がされているのは?(11)",
    answers: {
      a: "表の中から特定の条件に合致した行を取り出す<br>",
      b: "表の中から特定の列だけ取り出す<br>",
      c: "２つ以上の表の組みから条件にあった組み同士を繋ぎ合わせて新しい表を作る"
    },
    correctAnswer: "b"
 },
 {
    question: "DBMSが採用する３層スキーマ構造について間違っているものは?(11)",
    answers: {
      a: "外部スキーマ：利用者の必要となるデータの見方を表現（ビュー表がこれに該当、プログラムに加えた変更の影響はここで止まる）<br>",
      b: "概念スキーマ：データの論理的関係を表現（データベース本体といえる、プログラムとハードウェアに密接しているのでデータの独立性が保たれる）<br>",
      c: "内部スキーマ：データの物理的関係を表現（ハードウェア的な変更をここで吸収）"
    },
    correctAnswer: "b"
  },
  {
    question: "DBMSが３層スキーマ構造に採用する目的について正しいものは?(11)",
    answers: {
      a: "データの物理的な格納構造を変更してもアプリケーションプログラムに変更が及ぼさないようにするため<br>",
      b: "プログラム言語を限定してアプリケーションプログラムとDBMSを密接に結合するため<br>",
      c: "関係演算によって元の表から新たに表を作り出し、実在するように見せるため"
    },
    correctAnswer: "a"
  },
  {
    question: "関係データベースの主キー制約の条件として正しい組み合わせは?(11)",
    answers: {
      a: "①複数の列を組み合わせて一意となること　②キー値が空値でないこと（非NULL制約）<br>",
      b: "①キー値が重複していないこと（一意性制約）　②列の先頭にに定義されている列であること<br>",
      c: "①キー値が重複していないこと（一意性制約）　②キー値が空値でないこと（非NULL制約）"
    },
    correctAnswer: "c"
 },
 {
    question: "関係データベースの外部キーを定義する目的として正しいのは?(11)",
    answers: {
      a: "関係する相互のテーブル同士を関連付け、データの管理と抽出を行う<br>",
      b: "関係する相互のテーブルにおいてレコード間の参照一貫性が維持される制約を持たせる<br>",
      c: "障害によってデータを失った場合、レコードをテーブル相互の関係から可能な限り復旧させる"
    },
    correctAnswer: "b"
 },
 {
    question: "関係データベースにおける正規化の説明について正しいものは?(11)",
    answers: {
      a: "第１正規形：繰り返し部分を取り出して独立したレコードとして挿入<br>",
      b: "第２正規形：部分関数従属している列を切り出して表を分離させる<br>",
      c: "第３正規形：主キー以外の列に関数従属している列を削除する"
    },
    correctAnswer: "c"
  },
  {
    question: "SQL(Structured Query Language)のSELECT文の基本的な書式として間違っているものは?(11)",
    answers: {
      a: "SELECT 列名 FROM テーブル名 WHERE 条件<br>",
      b: "SELECT 列名 TO テーブル名 WHERE 条件<br>",
      c: "SELECT 列名 FROM テーブル名 "
    },
    correctAnswer: "b"
  },
  {
    question: "SQLのSELECT文において、特定の列を取り出す（射影）ときのSELECT文は?(11)",
    answers: {
      a: "SELECT ＊ FROM テーブル名 ORDER BY 列名 ASC<br>",
      b: "SELECT ＊ FROM テーブル名 WHERE 条件<br>",
      c: "SELECT 列名 FROM テーブル名"
    },
    correctAnswer: "c"
 },
 {
    question: "SQLのSELECT文において、特定の行を取り出す（選択）ときのSELECT文は?(11)",
    answers: {
      a: "SELECT ＊ FROM テーブル名 ORDER BY 列名 ASC<br>",
      b: "SELECT ＊ FROM テーブル名 WHERE 条件<br>",
      c: "SELECT 列名 FROM テーブル名"
    },
    correctAnswer: "b"
 },
 {
    question: "SQLのSELECT文において、表を結合する（結合）とき、次のSELECT文で[ ]に入る正しいものは?(11)<br>SELECT ＊ <br> FROM テーブル名1,テーブル名2<br> WHERE テーブル名1.列名[ ]テーブル名2.列名",
    answers: {
      a: "=<br>",
      b: "AND<br>",
      c: "+"
    },
    correctAnswer: "a"
  },
  {
    question: "SQLでデータを整列する際、値を上から小さい順に並べたい時はどれを使う?(11)",
    answers: {
      a: "ORDER BY 列名 DESC<br>",
      b: "ORDER BY 列名<br>",
      c: "SELECT 列名 FROM テーブル名"
    },
    correctAnswer: "b"
  },
  {
    question: "SQLにおいてデータを取り出す際、列の合計値や最大値、レコード（件数）などを求める際に用いられるのは?(11)",
    answers: {
      a: "集計関数<br>",
      b: "抽出関数<br>",
      c: "集合関数"
    },
    correctAnswer: "c"
 },
 {
    question: "SQLにおいてデータをグループ化する際、部署ごとの平均年齢を算出したい場合、[①]・[②]に入る組み合わせとして正しいものは(11)？※部署＝列名,社員情報＝テーブル名<br>SELECT 部署,[①] <br> FROM 社員情報<br> GROUP BY [②]",
    answers: {
      a: "①MAX(年齢)、②社員情報<br>",
      b: "①AVG(年齢)、②部署<br>",
      c: "①社員情報、②AVG(年齢)"
    },
    correctAnswer: "b"
 },
 {
    question: "SQLで部署ごとの平均年齢でグループ化した後、３０歳未満のものだけ取り出す条件をつけてグループを絞り込みたい場合、[?]に入る正しいものは(11)？<br>SELECT 部署,AVG(年齢) <br> FROM 社員情報<br> GROUP BY 部署<br> [?] AVG(年齢) < 30",
    answers: {
      a: "HAVING<br>",
      b: "TAKING<br>",
      c: "SEARCHING"
    },
    correctAnswer: "a"
  },
  {
    question: "トランザクションと排他制御に関して、データを読むことは可能だが書くことができない時データベースで行われている処理は?(11)",
    answers: {
      a: "共有ロック<br>",
      b: "専有ロック<br>",
      c: "デッドロック"
    },
    correctAnswer: "a"
  },
  {
    question: "トランザクションで求められるACID特性の”A”に該当する説明は?(11)",
    answers: {
      a: "複数のトランザクション処理でも単一処理を順番に実行したときでも結果が一致する<br>",
      b: "正常に終了したトランザクション更新結果は障害発生時でもデータベースから消去されない<br>",
      c: "トランザクション処理の結果がデータベース内容と矛盾しない<br>",
      d: "すべての処理が正常に通った時のみデータベースに反映される"
    },
    correctAnswer: "d"
 },
 {
    question: "トランザクションで求められるACID特性の”C”に該当する説明は?(11)",
    answers: {
      a: "複数のトランザクション処理でも単一処理を順番に実行したときでも結果が一致する<br>",
      b: "正常に終了したトランザクション更新結果は障害発生時でもデータベースから消去されない<br>",
      c: "トランザクション処理の結果がデータベース内容と矛盾しない<br>",
      d: "すべての処理が正常に通った時のみデータベースに反映される"
    },
    correctAnswer: "c"
 },
 {
    question: "トランザクションで求められるACID特性の”I”に該当する説明は?(11)",
    answers: {
      a: "複数のトランザクション処理でも単一処理を順番に実行したときでも結果が一致する<br>",
      b: "正常に終了したトランザクション更新結果は障害発生時でもデータベースから消去されない<br>",
      c: "トランザクション処理の結果がデータベース内容と矛盾しない<br>",
      d: "すべての処理が正常に通った時のみデータベースに反映される"
    },
    correctAnswer: "a"
  },
  {
    question: "トランザクションで求められるACID特性の”D”に該当する説明は?(11)",
    answers: {
      a: "複数のトランザクション処理でも単一処理を順番に実行したときでも結果が一致する<br>",
      b: "正常に終了したトランザクション更新結果は障害発生時でもデータベースから消去されない<br>",
      c: "トランザクション処理の結果がデータベース内容と矛盾しない<br>",
      d: "すべての処理が正常に通った時のみデータベースに反映される"
    },
    correctAnswer: "b"
  },
  {
    question: "トラブルでデータベースが一時機能しなくなったが、ログファイルで復旧することができた。これはトランザクション特性の何に当てはまるか?(11)",
    answers: {
      a: "Atomicity（原子性）<br>",
      b: "Consistency（一貫性）<br>",
      c: "Isolation（隔離性）<br>",
      d: "Durability（耐久性）"
    },
    correctAnswer: "d"
 },
 {
    question: "クライアントサーバシステムにおいて、クライアント側からストアドプロシージャを利用する利点は?(11)",
    answers: {
      a: "サーバのメモリ使用量を削減できる<br>",
      b: "クライアントとサーバの間の通信量を削減できる<br>",
      c: "サーバ内でのデータベースファイルへのアクセス量を削減できる"
    },
    correctAnswer: "b"
 },
 {
    question: "分散データベースシステムでトランザクション処理の更新の際、複数サイトにコミットの可否を問い合わせて、結果によってコミット・ロールバックを行う方式は?(11)",
    answers: {
      a: "2分探索法<br>",
      b: "排他制御<br>",
      c: "2相コミット"
    },
    correctAnswer: "c"
  },
  {
    question: "トランザクション処理中に障害が発生し、データベース更新に失敗した場合のデータベース復元に使用する①方法・②情報は?(11)<br>",
    answers: {
      a: "①ロールフォワード　②最新のバックアップファイル<br>",
      b: "①ロールバック　②更新前ジャーナル（ログファイルの更新前情報）<br>",
      c: "①ロールバック　②更新後ジャーナル（ログファイルの更新後情報）"
    },
    correctAnswer: "b"
  },
  {
    question: "バックアップ後の更新情報を逐一記録する更新前ジャーナルや更新後ジャーナルはどこに記録されるか?(11)",
    answers: {
      a: "ジャーナルと呼ばれるログファイル<br>",
      b: "ジャーナルと呼ばれるバックアップファイル<br>",
      c: "ジャーナルと呼ばれるデータベースファイル"
    },
    correctAnswer: "a"
  },
  {
    question: "データベースが故障した場合に復旧させるために使用する①方法、②処理の名前として正しいのは?(11)",
    answers: {
      a: "①バックアップファイルからデータを復元→更新前ジャーナルをすべて反映させる　②ロールバック<br>",
      b: "①バックアップファイルからデータを復元→更新後ジャーナルをすべて反映させる　②ロールフォワード<br>",
      c: "①ログファイルからデータを復元→更新後ジャーナルをすべて反映させる　②再編成"
    },
    correctAnswer: "b"
  },
  {
    question: "データベースのアクセス効率低下を防ぐために定期的に実施する処理は?(11)",
    answers: {
      a: "バックアップ<br>",
      b: "データベースダンプ<br>",
      c: "再編成"
    },
    correctAnswer: "c"
  },
  {
    question: "メモリの大分類として、RAM(Random Access Memory)とROM(Random Only Memory)があるが、それぞれの特性について正しい組み合わせは?(6)",
    answers: {
      a: "RAMの特性：「読み書き可で不揮発性」　ROMの特性：「読み出し専用で揮発性」<br>",
      b: "RAMの特性：「読み書き可で揮発性」　ROMの特性：「読み出し専用で不揮発性」<br>",
      c: "RAMの特性：「読み出し専用で揮発性」　ROMの特性：「読み書き可で不揮発性」"
    },
    correctAnswer: "b"
  },
  {
    question: "RAM(Random Access Memory)はさらにDRAM(Dynamic RAM)とSRAM(Static RAM)に分かれる。DRAMの特徴として間違っているものは?(6)",
    answers: {
      a: "安価で集積度が高いが低速、主に主記憶装置に使用される<br>",
      b: "使用する回路はコンデンサであり、コンデンサに蓄えた電荷の有無で情報を記憶するメモリである<br>",
      c: "コンデンサを使用しているため内容を再書き込みするリフレッシュ動作は不要である<br>",
      d: "SDRAMはDRAMの一種であり、DRAMよりも高速に動作する"
    },
    correctAnswer: "c"
  },
  {
    question: "RAM(Random Access Memory)はさらにDRAM(Dynamic RAM)とSRAM(Static RAM)に分かれる。SRAMの特徴として間違っているものは?(6)",
    answers: {
      a: "高価で集積度が低く高速、キャッシュメモリに用いられる<br>",
      b: "使用する回路はフリップフロップ回路である<br>",
      c: "フリップフロップ回路を使用しているためリフレッシュ動作が必要となる"
    },
    correctAnswer: "c"
  },
  {
    question: "ROM(Random Only Memory)について間違っている記述は?(6)",
    answers: {
      a: "PROM（Programmable ROM）という種類は、ユーザーの手で書き換えることができるROMである<br>",
      b: "マスクROMは製造時にデータを書き込んで出荷され、以降データを書き換える時は専用装置が必要となる。通常の「ROM」を指す<br>",
      c: "デジタルカメラなどで利用されているメモリーカード（SDカード）はPROMの１種であり、フラッシュメモリと呼ばれる"
    },
    correctAnswer: "b"
  },
  {
    question: "ROM(Random Only Memory)の種類について間違っている記述は?(6)",
    answers: {
      a: "EPROM(Erasable ROM):紫外線でデータを消去してデータを書き換える<br>",
      b: "EEPROM(Electlically PROM):電気的にデータを消去して書き換える<br>",
      c: "フラッシュメモリ:EEPROMの１種であり、ブロック単位でデータを消去するのではなく、全消去によりデータを書き換える"
    },
    correctAnswer: "c"
  },
  {
    question: "記憶装置ごとのアクセス速度について正しいのは？（左　速→遅　右）(6)",
    answers: {
      a: "CPUのレジスタ、メモリ（主記憶装置）、ハードディスクなどの磁気ディスク装置<br>",
      b: "メモリ（主記憶装置）、CPUのレジスタ、ハードディスクなどの磁気ディスク装置<br>",
      c: "ハードディスクなどの磁気ディスク装置、CPUのレジスタ、メモリ（主記憶装置）"
    },
    correctAnswer: "a"
  },
  {
    question: "記憶装置間の速度ギャップを埋めて待ち時間によるロスを防ぐためにキャッシュが用いられるがキャッシュメモリの説明として間違っているものは?(6)",
    answers: {
      a: "キャッシュは、１次キャッシュ・2次キャッシュ...というように重ねて設置することができる<br>",
      b: "SRAMをCPUの外側にキャッシュとして増設すると、CPUより低速だが容量が大きく持てるためキャッシュ効果が期待できる<br>",
      c: "メモリとCPU、メモリと磁気ディスク装置の間に設置されるキャッシュは同じものが使用される"
    },
    correctAnswer: "c"
  },
  {
    question: "主記憶装置を書き換える方式について、「プロセッサから主記憶装置への書き込みを減らすこと」を目的とする手法は?(6)",
    answers: {
      a: "ライトスルー方式<br>",
      b: "ライトバック方式<br>",
      c: "両方"
    },
    correctAnswer: "b"
  },
  {
    question: "主記憶装置を書き換える方式について、「キャッシュと主記憶の一貫性を保つこと」を目的とする手法は?(6)",
    answers: {
      a: "ライトスルー方式<br>",
      b: "ライトバック方式<br>",
      c: "両方"
    },
    correctAnswer: "a"
  },
  {
    question: "キャッシュミスが発生した時に、主記憶からデータが取り出されてキャッシュメモリに格納されるのは?(6)",
    answers: {
      a: "ライトスルー方式<br>",
      b: "ライトバック方式<br>",
      c: "両方"
    },
    correctAnswer: "c"
  },
  {
    question: "主記憶のアクセス時間が60ナノ秒、キャッシュメモリのアクセス時間が10ナノ秒のシステムがある。キャッシュメモリを介して主記憶にアクセスする場合の実行アクセス時間が15ナノ秒である時、キャッシュメモリのヒット率は?※ヒント：ヒット率とはキャッシュメモリに目的となるデータが入っている確率は？(6)",
    answers: {
      a: "0.17<br>",
      b: "0.9<br>",
      c: "0.83"
    },
    correctAnswer: "b"
  },
  {
    question: "主記憶を高速化する手法について、キャッシュメモリの以外に挙げられるメモリインタリーブの説明として正しいものは?(6)",
    answers: {
      a: "主記憶の中身を複数の区画（バンク）に分割しランダムアクセスすることで高速化する<br>",
      b: "主記憶の中身を複数の区画（バンク）に分割し同時アクセスすることで高速化する<br>",
      c: "主記憶の中身を記憶階層に分割し各層にアクセスすることで高速化する"
    },
    correctAnswer: "b"
  },
  {
    question: "通信路に関して、コンピュータ同士を互いに直接１本の回線で結び、通信相手は固定される方式をなんというか?(12)",
    answers: {
      a: "独占回線方式<br>",
      b: "専用回線方式<br>",
      c: "直接回線方式"
    },
    correctAnswer: "b"
  },
  {
    question: "１対１の回線ではなく、必要に応じた回線路が確立される交換方式について大別した２種類の説明で間違っているのは?(12)",
    answers: {
      a: "回線交換方式では、通信路に選ばれた回線は使用中のペアに占有されるため他の端末は占有中の回線を使用することはできない<br>",
      b: "パケット交換方式では、回線はパケット送信時のみ占有され、その間次のパケットは交換機が蓄積するため複数の端末で回線を使用することができる<br>",
      c: "WANの構築で拠点間を接続する場合などを除いて、現在のコンピュータネットワークで用いられるのは基本的に全て回線交換方式である"
    },
    correctAnswer: "c"
  },
  {
    question: "WANの構築で電気通信事業者の提供の通信サービスを用いて拠点間を繋ぐこととなるが、代表的な方法として説明が間違っているのは?(12)",
    answers: {
      a: "専用線：回線速度と距離によって費用が決まり、セキュリティは高いが高額である<br>",
      b: "フレームリレー方式：パケット交換方式をもとに伝送中の誤り制御を簡略化して高速化を図ったもので、データ転送の単位は可変長を用いる<br>",
      c: "ATM交換方式（セルリレー方式）：パケット交換方式をもとにデータ転送の単位を固定長のセル（53バイト）とすることで高速化を図ったものでパケット交換方式よりも伝送遅延は大きい",
      d: "広域イーサネット：LANで一般的に使われているイーサネット技術を用いて拠点間を接続するもので、コスト面メリットも大きく近年のWAN構築主流サービス"
    },
    correctAnswer: "c"
  },
  {
    question: "LANの接続形態（トポロジー）について間違っているのは?(12)",
    answers: {
      a: "スター型：ハブ中心として放射状に各コンピュータに接続　規格：イーサネット100BASE-TX,1000BASE-T<br>",
      b: "バス型：複数ケーブルに各コンピュータを接続　規格：イーサネット10BASE-2、10BASE-5<br>",
      c: "リング型：リング状に各コンピュータを接続　規格：トークンリング"
    },
    correctAnswer: "b"
  },
  {
    question: "イーサネットのアクセス制御方式CSMA/CD(Carrier Sense Multiple Access/Collision Detection)方式について間違っているのは?(12)",
    answers: {
      a: "Carrier Sense：ネットワーク上の通信状態を監視、他に通信を行うものがいなければデータの通信を開始する<br>",
      b: "Collision Detection：同時に送信してしまい衝突（コリジョン）が発生した場合は片方がランダムに求めた時間待機し、再度通信を開始する<br>",
      c: "Multiple Access：複数のコンピュータで通信を行うことができる"
    },
    correctAnswer: "b"
  },
  {
    question: "リング型LAN代表格トークンリングではアクセス制御方式にトークンパッシング方式を用いるが、その説明として間違っているのは?(12)",
    answers: {
      a: "平常時は送信権利を表すトークンがネットワーク上を流れている。この時のトークンをフリートークンという<br>",
      b: "データ送信時、フリートークンにデータを付けて流す。データ付きトークンをビジートークンという<br>",
      c: "ビジートークンが受信された時はその印をつけて再び流し、送信元に着くとフリートークンに戻して放流する",
      d: "２度使用されたトークンは使用不可となる"
    },
    correctAnswer: "d"
  },
  {
    question: "ホストコンピュータが集中的に処理し、他のコンピュータはそれにぶら下がる構成の「集中処理」と複数コンピュータに負荷を分担させる「分散処理」についての長所・短所が正しく説明されているのは?(12)",
    answers: {
      a: "「集中処理」長所：データの一貫性維持・管理のしやすさ・保守運用面　短所：システム拡張の際やホストコンピュータに故障があった際に問題<br>「分散処理」長所：システム拡張が簡単、一部コンピュータが故障しても支障が少ない　短所：セキュリティ確保や運用管理が大変<br>",
      b: "「集中処理」長所：システム拡張が簡単、一部コンピュータが故障しても支障が少ない　短所：セキュリティ確保や運用管理が大変<br>「分散処理」長所：データの一貫性維持・管理のしやすさ・保守運用面　短所：システム拡張の際やホストコンピュータに故障があった際に問題",
      c: "「集中処理」長所：集中的なホストコンピュータの処理によりコストダウンにつながる　短所：セキュリティ確保や運用管理が大変<br>「分散処理」長所：複数のコンピュータが同負担で稼働するためコストがかかる"
    },
    correctAnswer: "a"
  },
  {
    question: "「分散処理」であるが、「集中処理」の利点も取り入れた現在主流のシステム形態「クライアントサーバシステム」について間違っているのは?(12)",
    answers: {
      a: "クライアントは通常の処理は自前で行い、必要に応じてリクエストを投げる<br>",
      b: "サーバは集中的管理が必要な資源（プリンタやハードディスク）やサービス（メールやデータベース）を提供し、１台に複数サーバ機能がつくこともある<br>",
      c: "サーバは要求される側、クライアント要求側と役割が決まっている"
    },
    correctAnswer: "c"
  },
  {
    question: "プロトコルを７階層に分けたものは?(12)",
    answers: {
      a: "TCP/IPモデル<br>",
      b: "プロトコル７階層モデル<br>",
      c: "OSI基本参照モデル"
    },
    correctAnswer: "c"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について上位層３つの正しい順番は（左から上位層）?(12)",
    answers: {
      a: "プレゼンテーション層/アプリケーション層/セッション層<br>",
      b: "セッション層/プレゼンテーション層/アプリケーション層<br>",
      c: "アプリケーション層/プレゼンテーション層/セッション層"
    },
    correctAnswer: "c"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「物理層」の正しい説明は?(12)",
    answers: {
      a: "隣接する機器同士の通信を実現　利用例：Ethernet<br>",
      b: "物理的な接続、電気信号　利用例：UTPケーブル、光ファイバーケーブル<br>",
      c: "データを送る相手を決め最適な経路で送信　利用例：IP"
    },
    correctAnswer: "b"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「データリンク層」の正しい説明は?(12)",
    answers: {
      a: "隣接する機器同士の通信を実現　利用例：Ethernet<br>",
      b: "物理的な接続、電気信号　利用例：UTPケーブル、光ファイバーケーブル<br>",
      c: "データを送る相手を決め最適な経路で送信　利用例：IP"
    },
    correctAnswer: "a"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「ネットワーク層」の正しい説明は?(12)",
    answers: {
      a: "隣接する機器同士の通信を実現　利用例：Ethernet<br>",
      b: "物理的な接続、電気信号　利用例：UTPケーブル、光ファイバーケーブル<br>",
      c: "データを送る相手を決め最適な経路で送信　利用例：IP"
    },
    correctAnswer: "c"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「トランスポート層」の正しい説明は?(12)",
    answers: {
      a: "個々のアプリケーション　利用例：www,メール<br>",
      b: "データの表現形式　利用例：HTML<br>",
      c: "エンド間の通信制御　利用例：TCP,UDP",
      d: "通信手段　利用例：HTTPS"
    },
    correctAnswer: "c"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「セッション層」の正しい説明は?(12)",
    answers: {
      a: "個々のアプリケーション　利用例：www,メール<br>",
      b: "データの表現形式　利用例：HTML<br>",
      c: "エンド間の通信制御　利用例：TCP,UDP",
      d: "通信手段　利用例：HTTPS"
    },
    correctAnswer: "d"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「プレゼンテーション層」の正しい説明は?(12)",
    answers: {
      a: "個々のアプリケーション　利用例：www,メール<br>",
      b: "データの表現形式　利用例：HTML<br>",
      c: "エンド間の通信制御　利用例：TCP,UDP",
      d: "通信手段　利用例：HTTPS"
    },
    correctAnswer: "b"
  },
  {
    question: "プロトコルを７階層に分けたネットワーク層について「アプリケーション層」の正しい説明は?(12)",
    answers: {
      a: "個々のアプリケーション　利用例：www,メール<br>",
      b: "データの表現形式　利用例：HTML<br>",
      c: "エンド間の通信制御　利用例：TCP,UDP",
      d: "通信手段　利用例：HTTPS"
    },
    correctAnswer: "a"
  },
  {
    question: "TCP/IPプロトコルを使用したネットワークでは通信データをパケットにして分割、通信路へ流すが「パケット」について間違っているのは?(12)",
    answers: {
      a: "通信路上を流せるデータ量が有限であるためパケットに分ける<br>",
      b: "パケットには「送信元IPアドレス」「宛先IPアドレス」「ポート番号」がヘッダー情報として付加されている<br>",
      c: "データを分けずに流したとしても自動で分割し、ネットワークを利用できるようなシステムとなる"
    },
    correctAnswer: "c"
  },
  {
    question: "ネットワーク伝送速度について間違っているのは?(12)",
    answers: {
      a: "ネットワークに用いるケーブルは常に理論値100％である<br>",
      b: "一般的な使用法で出る速度のことを実行速度といい、理論値x伝送効率で求められる<br>",
      c: "理論値に対して実際に出る速度の割合を表すのが伝送効率で、実行速度÷理論値で求められる"
    },
    correctAnswer: "a"
  },
  {
    question: "LAN間接続装置で「IPアドレスを基にパケットを中継する」装置は?(12)",
    answers: {
      a: "リピータ<br>",
      b: "ブリッジ<br>",
      c: "ルーター<br>",
      d: "ゲートウェイ"
    },
    correctAnswer: "c"
  },
  {
    question: "LAN間接続装置で「MACアドレスを基にパケットを中継する」装置は?(12)",
    answers: {
      a: "リピータ<br>",
      b: "ブリッジ<br>",
      c: "ルーター<br>",
      d: "ゲートウェイ"
    },
    correctAnswer: "b"
  },
  {
    question: "LAN間接続装置で「同種のセグメント間で信号の増幅によって伝送距離を延長する」装置は?(12)",
    answers: {
      a: "リピータ<br>",
      b: "ブリッジ<br>",
      c: "ルーター<br>",
      d: "ゲートウェイ"
    },
    correctAnswer: "a"
  },
  {
    question: "LAN間接続装置で「OSI基本参照モデルにおける第４層以上のプロトコルを変換する」装置は?(12)",
    answers: {
      a: "リピータ<br>",
      b: "ブリッジ<br>",
      c: "ルーター<br>",
      d: "ゲートウェイ"
    },
    correctAnswer: "d"
  },
  {
    question: "ハブに関してリピータハブとスイッチングハブの違いとして間違っている説明は?(12)",
    answers: {
      a: "ポートへの送出がリピータハブは無条件であるが、スイッチングハブは宛先MACアドレスによって分岐する<br>",
      b: "リピータハブはセグメント内、スイッチングハブはセグメント間に使用される<br>",
      c: "リピータハブはリピータを、スイッチングハブはブリッジを複数束ねたもの"
    },
    correctAnswer: "b"
  },
  {
    question: "ハブに関してリピータハブとスイッチングハブの違いとして間違っている説明は?(12)",
    answers: {
      a: "ポートへの送出がリピータハブは無条件であるが、スイッチングハブは宛先MACアドレスによって分岐する<br>",
      b: "リピータハブはセグメント内、スイッチングハブはセグメント間に使用される<br>",
      c: "リピータハブはリピータを、スイッチングハブはブリッジを複数束ねたもの"
    },
    correctAnswer: "b"
  },
  {
    question: "送信側と受信側で生成多項式の処理を行うことで誤りの発生を検査する方法は?(12)",
    answers: {
      a: "CRC方式<br>",
      b: "垂直パリティチェック方式<br>",
      c: "水平パリティチェック方式",
      d: "ハミング符号方式"
    },
    correctAnswer: "a"
  },
  {
    question: "垂直パリティチェック方式と水平パリティチェック方式どちらか一方のみでは不可能であるが、双方を組み合わせた垂直水平パリティチェック方式で可能となるのは?(12)",
    answers: {
      a: "１ビットの誤りを検出できる<br>",
      b: "２ビット以上の誤りを検出できる<br>",
      c: "１ビットの誤りを訂正できる"
    },
    correctAnswer: "c"
  },
  {
    question: "TCP/IPの中核プロトコルについて間違っているのは?(12)",
    answers: {
      a: "ネットワーク層のIPはコネクションレス型の通信であり、経路制御を行いパケットを送信する<br>",
      b: "トランスポート層のTCPはコネクション型通信であり、パケットにはシーケンス番号等を付与して順序やエラー時の再送制御によりデータの信頼性を保証する<br>",
      c: "トランスポート層のUDPはコネクション型通信であり、リアルタイム性を重視しており高速で映像配信サービス等に使用される"
    },
    correctAnswer: "c"
  },
  {
    question: "同一ネットワーク内の全ホストに対して一斉に同じデータを送信することをなんという?(12)",
    answers: {
      a: "ブロードキャスト<br>",
      b: "ユニキャスト<br>",
      c: "マルチキャスト",
      d: "サブネットマスク"
    },
    correctAnswer: "a"
  },
  {
    question: "ホスト数はそんなにいらないが事業部ことにネットワークを分けたいという場合どの方法で実現すると良いか?(12)",
    answers: {
      a: "ブロードキャスト<br>",
      b: "ユニキャスト<br>",
      c: "マルチキャスト",
      d: "サブネットマスク"
    },
    correctAnswer: "d"
  },
  {
    question: "プライベートIPアドレスを持つ複数の端末が一つのグローバルIPアドレスを使ってインターネット接続を実現するものはどれか?(12)",
    answers: {
      a: "DNS<br>",
      b: "DHCP<br>",
      c: "NAPT"
    },
    correctAnswer: ""
  },
  {
    question: "?(12)",
    answers: {
      a: "<br>",
      b: "<br>",
      c: ""
    },
    correctAnswer: ""
  },
  {
    question: "?(12)",
    answers: {
      a: "<br>",
      b: "<br>",
      c: ""
    },
    correctAnswer: ""
  },
  {
    question: "クライアントサーバシステムについてシンクライアントの特徴として間違っているのは?(17)",
    answers: {
      a: "クライアント側の端末は、入力や表示機能だけを担当しそれ以外の機能はすべてサーバに任せる<br>",
      b: "強調動作するコンピュータ同士がやりとりするシステムであり、サーバなどの一元的に管理する存在を必要としない<br>",
      c: "クライアントに外部記憶装置のないシステムでは、サーバを防御することでウイルスなどの脅威にさらされるリスクを低減することができる"
    },
    correctAnswer: "b"
  },
  {
    question: "２層クライアントサーバシステムと３層クライアントサーバシステムの違いとして間違っているのは?(17)",
    answers: {
      a: "２層の方ではビジネスロジックがクライアント側にあるが、３層ではサーバ側にある<br>",
      b: "２層ではクライアント側はGUI操作を行うのみのため、シンクライアントを使用できる<br>",
      c: "３層はプレゼンテーション層、ファンクション層（アプリケーション層）、データ層に分かれる"
    },
    correctAnswer: "b"
  },
  {
    question: "システムの稼働形態として要求に対して即座に処理を行い、結果を反映させるものはどれ?(17)",
    answers: {
      a: "バッチ処理<br>",
      b: "リアルタイムトランザクション処理<br>",
      c: "オンライントランザクション処理"
    },
    correctAnswer: "c"
  },
  {
    question: "回線に負担を与えたくない場合や、ある程度まとめて処理する必要がある場合に用いられるシステム形態は?(17)",
    answers: {
      a: "バッチ処理<br>",
      b: "リアルタイムトランザクション処理<br>",
      c: "オンライントランザクション処理"
    },
    correctAnswer: "a"
  },
  {
    question: "性能測定用のソフトウェアを使用してシステムの各処理性能を数値化するベンチマークテストについて間違っている説明は?(17)",
    answers: {
      a: "想定されるトランザクション量にシステムが耐えられるかを判定する<br>",
      b: "測定用ソフトウェアを使用して各処理性能を数値化する<br>",
      c: "すべての評価が網羅できて完了というわけではないが傾向をつかむ一定の目安として役立てる"
    },
    correctAnswer: "a"
  },
  {
    question: "性能指標について単位時間あたりに処理できるジョブ量で計測され、結果の数字が大きいほど高性能とされるのは?(17)",
    answers: {
      a: "スループット<br>",
      b: "レスポンスタイム<br>",
      c: "ターンアラウンドタイム"
    },
    correctAnswer: "a"
  },
  {
    question: "オンライントランザクション処理で用いられる性能指標は?(17)",
    answers: {
      a: "スループット<br>",
      b: "レスポンスタイム<br>",
      c: "ターンアラウンドタイム"
    },
    correctAnswer: "b"
  },
  {
    question: "バッチ処理で用いられる性能指標は?(17)",
    answers: {
      a: "スループット<br>",
      b: "レスポンスタイム<br>",
      c: "ターンアラウンドタイム"
    },
    correctAnswer: "c"
  },
  {
    question: "スループットに関する説明として間違っているのは?(17)",
    answers: {
      a: "多重プログラミングはスループット向上に役立つ<br>",
      b: "ジョブ終了〜次のジョブ開始間にオペレータ介入による遊休時間が生じてもスループットに影響を及ぼさない<br>",
      c: "プリンタへの出力を一時的に磁気ディスク装置へ保存するスプーリングはスループット向上に役立つ"
    },
    correctAnswer: "b"
  },
  {
    question: "システムを止めない工夫として「同じ処理を行うシステムを二重に用意して処理結果を照合し、どちらかのシステムに障害が発生した場合でも縮退運転によって処理を継続する」ものは?(17)",
    answers: {
      a: "ホットスタンバイ<br>",
      b: "デュプレックスシステム<br>",
      c: "デュアルシステム"
    },
    correctAnswer: "c"
  },
  {
    question: "システムを止めない工夫として「２組のシステムを主系と従系に分けて普段は従系を待機状態にしておき、主系が故障した際に従系が代わりをする」ものは?(17)",
    answers: {
      a: "ホットスタンバイ<br>",
      b: "デュプレックスシステム<br>",
      c: "デュアルシステム"
    },
    correctAnswer: "b"
  },
  {
    question: "デュプレックスシステムの待機方法「ホットスタンバイ」についての説明が正しいのは?(17)",
    answers: {
      a: "主系から引き継ぐ準備としてプログラムを起動しておくため瞬時に切り替えが可能だが、コストはかかる<br>",
      b: "普段から２組のシステムが同じ処理をしているため、片方が壊れてもなんの支障もなく処理を続けられる<br>",
      c: "従系は普段別の作業をしていたり電源がオフであったりするためコストダウンが望めるが、主系が故障した際切り替えに時間がかかる"
    },
    correctAnswer: "a"
  },
  {
    question: "システムの信頼性を評価する概念「RASIS(ラシス)」について正しい組み合わせは?<br>Reliability（信頼性）、Availability（可用性）、Serviceability（保守性）、Integrity（保全性）、Security（安全性）(17)",
    answers: {
      a: "R:障害発生時どれだけ早く発見・修復が行えるか（指標値 MTTR）　A:必要な時にいつでも利用できる状態にあること（指標値 稼働率）　S:システムが稼働し続けること（指標値 MTBF）<br>",
      b: "R:必要な時にいつでも利用できる状態にあること（指標値 稼働率）　A:システムが稼働し続けること（指標値 MTBF）　S:障害発生時どれだけ早く発見・修復が行えるか（指標値 MTTR）<br>",
      c: "R:システムが稼働し続けること（指標値 MTBF）　A:必要な時にいつでも利用できる状態にあること（指標値 稼働率）　S:障害発生時どれだけ早く発見・修復が行えるか（指標値 MTTR）"
    },
    correctAnswer: "c"
  },
  {
    question: "平均故障間隔（MTBF：Mean Time Between Failure）について、稼働サイクルが「80h/２h故障/120h/６h故障/40h/４h故障」のMTBFは?(17)",
    answers: {
      a: "80時間<br>",
      b: "４時間<br>",
      c: "120時間%"
    },
    correctAnswer: "a"
  },
  {
    question: "平均修理時間（MTTR：Mean Time To Repair）について、稼働サイクルが「80h/２h故障/120h/６h故障/40h/４h故障」のMTTRは??(17)",
    answers: {
      a: "80時間<br>",
      b: "４時間<br>",
      c: "120時間"
    },
    correctAnswer: "b"
  },
  {
    question: "稼働サイクル「80h/２h故障/120h/６h故障/40h/４h故障」のシステム稼働率は?(17)",
    answers: {
      a: "75%<br>",
      b: "85%<br>",
      c: "95%"
    },
    correctAnswer: "c"
  },
  {
    question: "稼働率0.９0の直列接続システムの全体稼働率は?(17)",
    answers: {
      a: "71%<br>",
      b: "81%<br>",
      c: "91%"
    },
    correctAnswer: "b"
  },
  {
    question: "稼働率0.９0の並列接続システムの全体稼働率は?(17)",
    answers: {
      a: "79%<br>",
      b: "89%<br>",
      c: "99%"
    },
    correctAnswer: "c"
  },
  {
    question: "システムの故障に関する考え方について間違っている説明は?(17)",
    answers: {
      a: "フォールトトレラントを実現する方法としてフェールセーフ「安全性が最優先」　フェールソフト「継続性が最優先」　フールプルーフ「意図しない使い方をしても故障しないようにする」がある<br>",
      b: "フォールトアボイダンスは、システム構成を簡易化して「故障そのものの発生を防ごう」という考え方<br>",
      c: "フォールトトレラントを実現するためにはシステムに冗長性を持たせ一部の故障を全体に影響させないように対策することが必要"
    },
    correctAnswer: "b"
  },
  {
    question: "故障の発生頻度と時間の関係をグラフにした「バスタブ曲線」の経過について正しいものは？(17)",
    answers: {
      a: "納品保証期間→偶然故障期間→終焉故障期間<br>",
      b: "初期故障期間→偶発故障期間→摩擦故障期間<br>",
      c: "初期故障期間→偶発故障期間→後期故障期間"
    },
    correctAnswer: "b"
  },
  {
    question: "システム開発に必要となるコスト（初期コストや運用コスト）を総称したものは?(17)",
    answers: {
      a: "TOM<br>",
      b: "TTC<br>",
      c: "TCO"
    },
    correctAnswer: "c"
  },
  {
    question: "バックアップの種類について、バックアップの際必要となる「データ量と処理時間」が少ない順に並べられたものは?(17)",
    answers: {
      a: "フルバックアップ→増分バックアップ→差分バックアップ<br>",
      b: "増分バックアップ→差分バックアップ→フルバックアップ<br>",
      c: "差分バックアップ→増分バックアップ→フルバックアップ"
    },
    correctAnswer: "b"
  },
  {
    question: "10進数の演算式7÷32の結果を２進数で表したものは?(1)",
    answers: {
      a: "0.001011<br>",
      b: "0.001101<br>",
      c: "0.000111"
    },
    correctAnswer: "c"
  },
  {
    question: "10進数小数のうち2進数で表すと無限小数になるものは?(1)",
    answers: {
      a: "0.375<br>",
      b: "0.125<br>",
      c: "0.05"
    },
    correctAnswer: "c"
  },
];


buildQuiz();

submitButton.addEventListener('click', showResults);
